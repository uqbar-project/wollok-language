{
  "nameShouldBeginWithLowercase": "El nombre {0} debe comenzar con minúsculas",
  "nameShouldBeginWithUppercase": "El nombre {0} debe comenzar con mayúsculas",
  "nameShouldNotBeKeyword": "El nombre {0} es una palabra reservada, debe cambiarla",
  "shouldNotBeEmpty": "El elemento no puede estar vacío: falta escribir código.",
  "shouldUseConditionalExpression": "Estás usando incorrectamente el if. Devolvé simplemente la expresión booleana.",
  "shouldPassValuesToAllAttributes": "No se puede instanciar {0}. Falta pasar valores a los siguientes atributos: {1}",
  "namedArgumentShouldExist": "No se encuentra la referencia {0} en {1}",
  "linearizationShouldNotRepeatNamedArguments": "La referencia {0} está inicializada más de una vez",
  "namedArgumentShouldNotAppearMoreThanOnce": "La referencia {0} está inicializada más de una vez",
  "shouldInitializeAllAttributes": "Debe proveer un valor inicial a las siguientes referencias: {0}",
  "shouldImplementAllMethodsInHierarchy": "Existen métodos en la jerarquía que requieren implementación en super: {0}",
  "shouldUseSelfAndNotSingletonReference": "No debe usar el nombre del objeto dentro del mismo. Use 'self'.",
  "shouldNotReassignConst": "No se pueden modificar las referencias constantes",
  "shouldNotHaveLoopInHierarchy": "La jerarquía de clases produce un ciclo infinito",
  "shouldOnlyInheritFromMixin": "Los mixines solo pueden heredar de otros mixines",
  "shouldNotDefineMoreThanOneSuperclass": "Linearización: no se puede definir más de una superclase",
  "superclassShouldBeLastInLinearization": "Linearización: la superclase debería estar última en linearización",
  "shouldNotUseOverride": "Este método no sobrescribe ningún otro método",
  "possiblyReturningBlock": "Este método devuelve un bloque, si no es la intención elimine el '=' antes de las llaves.",
  "shouldUseOverrideKeyword": "Debería marcarse el método con 'override', ya que sobrescribe el de sus superclases",
  "shouldMatchSuperclassReturnValue": "El método ${0} que sobreescribe la subclase debe respetar el mismo tipo que el método de su superclase (sea un método que solo produce efecto o que devuelve un valor).",
  "getterMethodShouldReturnAValue": "El método getter debe retornar un valor",
  "methodShouldHaveDifferentSignature": "Método duplicado",
  "shouldNotDuplicateVariables": "Ya existe una variable con este nombre en la jerarquía",
  "shouldNotDuplicateFields": "Ya existe un atributo con este nombre en la jerarquía",
  "shouldNotDuplicateLocalVariables": "Ya existe una variable local con este nombre en la jerarquía",
  "shouldNotDuplicateGlobalDefinitions": "Ya existe una definición con este nombre en la jerarquía",
  "shouldNotDuplicateVariablesInLinearization": "En la jerarquía hay atributos con el mismo nombre: [{0}]",
  "shouldNotDuplicateEntities": "Este nombre ya está definido (importado de {0})",
  "shouldNotImportSameFile": "No se puede importar el mismo archivo",
  "shouldNotImportMoreThanOnce": "Este archivo ya está importado",
  "parameterShouldNotDuplicateExistingVariable": "Nombre duplicado",
  "methodShouldExist": "El método no existe o número incorrecto de argumentos",
  "shouldImplementInheritedAbstractMethods": "Debe implementar todos los métodos abstractos heredados",
  "shouldHaveBody": "El método debe tener una implementación",
  "shouldNotUseVoidMethodAsValue": "El mensaje \"{0}\" no retorna ningún valor (quizás te falte un return en el método)",
  "shouldNotAssignValueInLoop": "Se genera un loop infinito en la asignación del valor",
  "shouldInitializeGlobalReference": "La referencia nunca se inicializa",
  "shouldNotDefineUnusedVariables": "Esta variable nunca se utiliza",
  "shouldNotDefineGlobalMutableVariables": "Solo se permiten las variables globales de tipo const",
  "shouldDefineConstInsteadOfVar": "Esta variable debería ser una constante",
  "shouldNotCompareEqualityOfSingleton": "No se aconseja comparar objetos nombrados, considere utilizar polimorfismo.",
  "shouldUseBooleanValueInIfCondition": "Se espera un booleano",
  "shouldUseBooleanValueInLogicOperation": "Se espera un booleano",
  "shouldNotDefineUnnecesaryIf": "If innecesario. Siempre se evalúa como verdadero",
  "codeShouldBeReachable": "Este código nunca se va a ejecutar",
  "shouldNotDefineUnnecessaryCondition": "Condición innecesaria",
  "shouldCatchUsingExceptionHierarchy": "Solo se puede aplicar 'catch' a un objeto de tipo wollok.lang.Exception o una subclase",
  "catchShouldBeReachable": "Este catch nunca se va a ejecutar debido a otro catch anterior",
  "shouldNotUseReservedWords": "{0} es una palabra reservada por la biblioteca de Wollok",
  "shouldNotDuplicatePackageName": "Package duplicado",
  "shouldMatchFileExtension": "La extensión del archivo no permite esta definición",
  "shouldHaveNonEmptyName": "Los tests deben tener una descripción no vacía",
  "shouldHaveAssertInTest": "Los tests deben enviar al menos un mensaje al WKO \"assert\"",
  "overridingMethodShouldHaveABody": "Si sobrescribe debe especificar el cuerpo del método",
  "shouldNotDefineEmptyDescribe": "El describe no debería estar vacío",
  "shouldNotMarkMoreThanOneOnlyTest": "Solo un test puede marcarse como 'only' (los otros no se ejecutarán)"
}