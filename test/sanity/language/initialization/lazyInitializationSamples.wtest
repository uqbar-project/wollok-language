/**
  * Scenario: a simple initialization class with well ordered variable declarations
  */
class A {
  var y = 0
  var property x = y + 1

  method m() = y + x
}

describe "lazy initialization for well-ordered declarations in class" {

  test "value of lazy attribute" {
    assert.equals(1, new A().x())
  }

  test "test sum of all attributes" {
    assert.equals(1, new A().m())
  }

  test "value of lazy attribute if initialized with named parameter" {
    assert.equals(5, new A(x = 5).x())
  }

}

/**
  * Scenario: a simple initialization class with unordered variable declarations
  */
class B {
  var property x = y + 1
  var property y = 0

  method m() = x + y
}

describe "lazy initialization for well-ordered declarations in class" {

  test "test lazy attribute" {
    assert.equals(1, new B().x())
  }

  test "test sum of all attributes" {
    assert.equals(1, new A().m())
  }

}

/**
  * Scenario: a class with several lazy definitions, interacting with named parameters
  */
class C {
  var property a = 1
  const property b = a + 1
  const property c = b + a

  method m() = a + b + c
}

describe "lazy initialization on instances" {

  test "overriding default initialization: variable -> value" {
    assert.equals(3, new C(a = 2).b())
  }

  test "overriding default initialization 2: variable -> value" {
    assert.equals(2, new C().b())
  }

  test "overriding initialization and using an expression in definition" {
    assert.equals(8, new C(b = 7).c())
  }

  test "overriding default initialization: variable -> expression" {
    assert.equals(1, new C(b = 3).a())
  }

  test "overriding default initialization: variable -> expression - 2" {
    assert.equals(2, new C(c = 2).c())
  }

}

